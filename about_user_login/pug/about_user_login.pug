doctype html
html(lang="ja")

head
  meta(charset="utf-8")
  title about_user_login
  link(rel="stylesheet",href="../sass/about_user_login.css")

body
h1.project_title ログイン機能を自力で一から作成する(user_login) 
p 
  a(href="https://github.com/yuyu456-corder/user_login",target="_blank") user_loginリポジトリへのリンク
  h2 プロジェクト概要
  p ログイン機能そのものを外部のAPI等を使わず自力で開発する
  h2 どうして作ろうと思ったか
  p 普段何気なく使っているログイン機能、外部サービスのAPI等で簡単に実装できるが実際はHTTP(S)通信・セキュリティ面・データベース連携等、
  |様々な技術が使われている。あえて自力でこれらを学びつつログイン機能を作成することで、
  |得られる知識が多いと思い作成を開始しました。
  h2 開発環境
  table#dev_tools(border=1,flame="border",rules="all")
    tbody
      tr
        td OS
        td Windows
      tr
        td エディタ（IDE）
        td Visual Studio Code
      tr
        td バージョン管理ソフト
        td git/GitLab/GitHub
      tr
        td(rowspan="2") 開発言語
        td JavaScript
      tr
        td Node.js/Vue.js/Express.js
      tr  
        td(rowspan="2") その他ツール
        td SQLite(RDBMS)
      tr
        td Sequelize(ORM)
  h2 将来的な運用について
  p ログイン機能でユーザごとに権限があるマイページに安全に移動させる事ができたら、他に開発しているWebサービスにマージして運用していきたいです。
  p また、UI、UXの面からユーザにとってよりよい操作性やデザインのログインページにブラッシュアップできたらと思っております。
  h2 開発時に自分が苦労した点
    h3 ORMの理解
    p SQL文をJavaScript内のコードに書いてしまうと保守性や可読性が落ちると懸念したためORMを実装しました。
    |ORMはSequelizeを使用しましたが、上手くDBに接続できない、テーブルが認知されない等のエラーに悩まされましたが、
    br
    |公式のリファレンスを読むことで少しずつ理解を深めていきました。
    h3 データ通信を意識した事
    p 今まで、CやVHDL等のハードウェア寄りの言語を扱っていた為、サーバとクライアントが通信するという認識が曖昧でした。
    |そもそもネットワークの知識から不足していると考え、関連する書籍や応用情報の参考書、ネット上の有識者の記事等から、
    |OSI基本参照モデルから根本的に理解することにしました。
    br
    P 今までHTTP(S)と曖昧に認識していたものがようやく実態になって理解できました。
    h3 promiseによる非同期処理の理解
    p サーバを作成する際、node.jsの非同期処理に最初悩まされました。
    |サーバのレスポンスを待たず、結果（undefined）を返してしまったり、自身が書いたコードの実行順が分からなくなってしまうという事態が発生しました。
    br
    |ES2015から実装されたpromiseを用いた構文でサーバの処理を書くことでこれらの問題を解決したと共に、
    br
    |非同期処理、同期処理の使い分けを意識できるようになりました。

h1.system_constitution システム構成について
p user_loginのシーケンス図を下記に示しています。
img#sequence_diagram(src="../assets/sequence_diagram.png",alt="シーケンス図",width="60%")

p ユーザの操作を受け付けたり、画面描画を行うフロントエンド用サーバ
|フロントエンドで受け取ったデータを元にデータベースと連携した操作を行うバックエンド用サーバ（APIサーバ）
|この2つのサーバが主軸となり、システムを構築しています。
p この2つのサーバ間ではHTTP通信を行っており、バックエンド用のサーバのルーティング処理を切り替える事でCRUD処理を実装しています。

h1.about_function 実装機能の説明
  h2 データベース連携によるユーザ情報のCRUD処理
  p SQLite＋Sequelizeにより、JavaScript（Node.js+Express.js）で
  |アカウントの新規登録、登録ユーザの表示、既存ユーザの情報変更、既存ユーザの削除を行う処理を実装しました。
  img(src="../assets/user_registration.gif",alt="ユーザ新規登録")
  figcaption ユーザの新規登録の例
  p 上記のGIFアニメより、"Takahashi"というユーザ名を入力し、登録処理を行いました。
  |登録処理後に、管理者画面に戻ると"Takahashi"のアカウント情報が表示されています。
  br
  |右側のターミナルで左側のブラウザの入力内容がサーバに送られ、DBに格納しています。
  br
  |DBに登録が終了したことをレスポンストとしてブラウザに返すという一連の流れでCRUD処理を行っています。
  h2 より安全なユーザ認証
    h3 登録したユーザのパスワードの暗号化
    p SQLiteはパスワード設定を行わないためDBの情報が常に外部に晒されています。
    |パスワードのような悪用されるであろうデータはハッシュ値を計算して暗号化しています。
    br
    |DBと通信する際にサーバ側でパスワードを復号するため、ユーザ側は平文のパスワードのままでログイン処理を行えます。
    img(src="../assets/encrypted_password.png",alt="暗号化されたパスワード例")
    figcaption 暗号化されたパスワード例（passwordのカラム参照）
    br
    h3 アクセストークンによるユーザ認証
    |登録したユーザに対しアクセストークンを発行することでより安全なユーザ認証機能を実現させました。
    p アクセストークンはJsonWebTokenを用いて、HS256(共通鍵暗号方式)で暗号化します。
    |このプロジェクトでは認可サーバとAPIサーバが同一でサーバ間の通信が行われないためRS256（公開鍵暗号方式）ではなく
    |導入コストの少ないHS256を暗号化のアルゴリズムに採用しています。
    br
    p 秘密鍵の情報は公開していないため、外部からこのトークンが復号化されるリスクを減らしています。
    img(src="../assets/token_generated.gif",alt="生成されたトークン例")
    figcaption 発行されたアクセストークンの例

  p 左側がログイン画面のブラウザで、右側がサーバ側の処理のログを出しているターミナルです。
  |ログインが成功すると、そのユーザに対して一意なアクセストークンを発行しています。
  |ターミナルのgenerated Token:～以降に表示されているのがアクセストークンとなります。